<!---

This file is used to generate your project datasheet. Please fill in the information below and delete any unused
sections.

You can also include images in this folder and reference them in the markdown. Each image must be less than
512 kb in size, and the combined size of all images must be less than 1 MB.
-->

## Background

### What is an XOR stream Cipher? 
An XOR stream cipher is a type of symmetric-key encryption algorithm that encrypts data one bit or byte at a time, in a continuous stream. In a stream cipher, the encryption key is combined with a stream of pseudo-random bits or bytes to generate a sequence of cipher symbols, which are then combined with the plaintext message using the XOR (exclusive OR) operation to generate the ciphertext.

Unlike block ciphers, which encrypt fixed-size blocks of plaintext at a time, stream ciphers can encrypt data of any size in a continuous stream, making them well-suited for real-time communication applications such as wireless communications or internet telephony. Stream ciphers are also often faster and more efficient than block ciphers, since they require less computation and memory.

However, stream ciphers can be vulnerable to certain types of attacks, such as known-plaintext attacks or stream cipher resynchronization attacks, if the key stream is not properly generated or the same key stream is used multiple times.

### Galois LFSR
An LFSR is a shift register whose output bit is a linear function of its previous state. In a Galois LFSR, the linear function is implemented using exclusive-OR (XOR) operations between selected bits of the register. The XOR feedback taps should be chosen in a way that generates a maximal length sequence, which is a pseudo-random sequence of bits that has the longest possible period for a given register length.

The Galois LFSR operates by shifting the bits in the register to the right, with the rightmost bit being discarded and a new bit being added at the leftmost position. The new bit is generated by performing XOR operations between selected bits of the register, as determined by the feedback taps. The sequence of bits generated by the LFSR is periodic, with the period being determined by the size of the register and the feedback taps used.


## How it works

The design has two channels, one for **encryption** and another for **decryption**, each controlled by a separate enable pin. The plaintext or ciphertext bitstream is XORed with a bit derived from a register variable generated by a **Linear Feedback Shift Register (LFSR)**.  

The LFSR is **programmable/customizable** to operate in **32-bit, 16-bit, 8-bit, or 4-bit modes**, depending on the select lines `sel0` and `sel1`. This provides flexibility in choosing the level of security and performance trade-off.  

During **transmission**, the plaintext (`tx_p`) is encrypted into `tx_e`. For **reception**, the encrypted stream (`rx_e`) is decrypted back into the original plaintext (`rx_p`) using the same LFSR sequence. Debug outputs (`dbg_tx_p`, `dbg_rx_e`) are available for testing but are disabled by default.  

The configuration input (`cfg_i`) and enable (`cfg_en`) allow dynamic loading of the 130-bit serial shift register, ensuring the LFSR sequence can be customized at runtime. The `cfg_o` pin provides read-back capability for verification.  

## How to test

A testbench is provided at `../test/tb_testing.v`.  

- The primary input is assigned to the variable **`custom_input`**.  
- The bit-width of this input can be adjusted by modifying the **`size`** variable.  

Update these variables in the testbench, run the simulation.
